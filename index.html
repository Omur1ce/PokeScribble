<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Pok√©Scribble ‚Äî Guess the Pok√©mon</title>
<meta name="description" content="Guess them pokemon scribbles guys">
<link href="https://fonts.googleapis.com/css2?family=Comic+Relief:wght@400;700&display=swap" rel="stylesheet">


<style>
  
  :root{
    --glass: rgba(255,255,255,.78);
    --text:#1a1a1a;
    --accent:#ef476f;
    --accent2:#118ab2;
    --ok:#0a8f4a;
    --err:#d90429;

    --bg-light: url("sprites/background_light.jpg");
    --bg-dark:  url("sprites/background_dark.jpg");
    --bg-image: var(--bg-light);
    --mainframe: url("sprites/main_frame3.jpeg");
    --font-scribble: "Comic Relief", cursive, sans-serif;
    --font-ui: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  }

  html, body { height: 100%; }
  
  html{
  font-synthesis: none;
  }
  body{
    font-family: var(--font-ui);
  }
  
.sub,
.meta,
.pill,
.label,
.msg,
.tag{
  font-family: var(--font-scribble);
  letter-spacing: 0.04em;
}

.disclaimer{
  margin-top: 6px;
  text-align: center;
  font-size: 0.9rem;
  line-height: 1.3;
  opacity: 1.0;

  /* matches your cartoony font system */
  font-family: var(--font-scribble);
}


/* Keep inputs clean & readable */
input,
.ac-item{
  font-family: var(--font-scribble);
  letter-spacing: 0.04em;
}


.bg{
  position:fixed;
  inset:0;
  background-image: var(--bg-image);
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  z-index:-2;
  transition: background-image 0.5s ease;
}

  .bg::after{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(900px 500px at 105% 20%, rgba(255,255,255,.45), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.28), rgba(0,0,0,.18));
    z-index:-1;
  }

  .wrap{ min-height:100%; display:grid; place-items:center; padding:5vh 16px; }
.card{
  width:min(1100px, 96vw);

  /* REMOVE the glass look */
  background: transparent;
  border: none;
  box-shadow: none;
  backdrop-filter: none;
  -webkit-backdrop-filter: none;

  border-radius: 0;   /* frame defines shape now */

  padding: clamp(18px, 4vw, 36px);

  position: relative;
  overflow: visible;
  isolation: isolate;
  z-index: 1; /* card content layer */
}

  /* Big outer frame overlay (outermost bounding box) */
  .card::before{
    content:"";
    position:absolute;
    inset: 0;

    /* tweak these two values manually */
    transform: translate(20px, 0px) scale(1.05, 1.08);
    transform-origin: center;

    background: var(--mainframe) center / 100% 100% no-repeat;

    z-index: -1; /* card content layer */
    pointer-events:none;
  }

  .topbar{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }

  .title{ display:flex; gap:12px; align-items:center; margin:0 0 8px; text-transform:uppercase; letter-spacing:.02em; }
  .title b{ font-size: clamp(1.3rem, 3.6vw, 2.1rem); }
  .pokeball{ width:36px; height:36px; border-radius:50%; flex:0 0 auto;
    background:
      radial-gradient(circle at 50% 50%, #fff 0 7px, transparent 7px),
      linear-gradient(#ff3b3b 0 50%, #fff 50% 100%);
    border:3px solid #1a1a1a; box-shadow: inset 0 2px 0 rgba(0,0,0,.15), 0 6px 18px rgba(0,0,0,.15);
  }
  .sub{ margin:0 0 14px; color:#333; }
  /* .hr{ height:3px; border-radius:3px; background:linear-gradient(90deg, var(--accent), var(--accent2)); margin:10px 0 20px; } */

  .meta{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; color:#333; }
  .pill{ background:#0000000e; padding:6px 10px; border-radius:999px; }

  .toggle{
    display:flex; align-items:center; gap:10px;
    background:#ffffffb0;
    border:1px solid rgba(0,0,0,.10);
    padding:8px 10px;
    border-radius:999px;
    user-select:none;
  }
  .toggle span{ font-size:.92rem; color:#222; }
  .switch{ position:relative; width:46px; height:26px; flex:0 0 auto; }
  .switch input{ opacity:0; width:0; height:0; }
  .slider{
    position:absolute; inset:0;
    background:rgba(0,0,0,.18);
    border-radius:999px;
    transition: .2s;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.08);
  }
  .slider:before{
    content:"";
    position:absolute; height:20px; width:20px; left:3px; top:3px;
    background:white;
    border-radius:50%;
    transition:.2s;
    box-shadow:0 6px 18px rgba(0,0,0,.18);
  }
  .switch input:checked + .slider{ background:rgba(17,138,178,.45); }
  .switch input:checked + .slider:before{ transform: translateX(20px); }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap: 16px;
  }
  @media (min-width: 900px){
    .grid{ grid-template-columns: repeat(3, 1fr); }
  }

.imgbox{
  position: relative;
  aspect-ratio: 1 / 1;     /* lock scribble area */
  isolation: isolate;
}

/* ===== Frame 1 ===== */
.imgbox.frame-1::before{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:100%;
  height:100%;

  transform: translate(-52%, -50%) scale(2, 1.4);
  transform-origin: center;

  background: url("sprites/frame1.jpeg") center / 100% 100% no-repeat;

  z-index: 5;
  pointer-events:none;
}

/* ===== Frame 2 ===== */
.imgbox.frame-2::before{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:100%;
  height:100%;

  transform: translate(-55%, -50%) scale(1.9, 1.38);
  transform-origin: center;

  background: url("sprites/frame2.jpeg") center / 100% 100% no-repeat;

  z-index: 5;
  pointer-events:none;
}

/* ===== Frame 3 ===== */
.imgbox.frame-3::before{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:100%;
  height:100%;

  transform: translate(-55%, -49%) scale(2.05, 1.38);
  transform-origin: center;

  background: url("sprites/frame3.jpeg") center / 100% 100% no-repeat;

  z-index: 5;
  pointer-events:none;
}


/* Keep puzzle content above/below as desired:
   If you want frame on top, content must be UNDER it (z-index lower) */
.puzzle > *{
  position: relative;
  z-index: 1;
}




  .imgbox{
    background:#fff;
    border-radius:14px;
    padding:12px;
    display:grid;
    place-items:center;
    min-height:240px;
    position:relative;
    margin-bottom: 12px;
  }
  .imgbox img{
    max-width:100%;
    max-height:320px;
    object-fit:contain;
  }
  .label{ font-weight:700; margin-bottom:8px; }
  .input-wrap{ position:relative; }
  input[type="text"]{
    width:100%;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.14);
    background:#fff;
    color:#111;
    font-size:1rem;
    outline:none;
  }
  input[type="text"]:focus{ border-color:var(--accent2); box-shadow:0 0 0 3px rgba(17,138,178,.20); }
  .msg{ margin-top: 0; }
  .ok{ color:var(--ok); } .err{ color:var(--err); }

  .ac-list{
    position:absolute; left:0; right:0; top:100%; z-index:20;
    margin-top:6px; max-height:220px; overflow:auto;
    background:#ffffff; border:1px solid rgba(0,0,0,.12); border-radius:12px;
    box-shadow:0 16px 40px rgba(0,0,0,.15);
  }
  .ac-item{ padding:10px 12px; cursor:pointer; display:flex; gap:8px; align-items:center; color:#111; }
  .ac-item:hover, .ac-item[aria-selected="true"]{ background:#f3f8ff; }
  .dex{ opacity:.7; font-variant-numeric:tabular-nums; min-width:3ch; }
  .hide{ display:none; }


  .title-img{
  max-height: 200px;   /* tweak as needed */
  width: auto;
  }

.logo-img{
  max-height: 150px;   /* tweak as needed */
  width: auto;
  margin-left: auto; /* pushes logo to the far right */
}

  /* Grey-out card when dark mode is active */
  body.dark .card{
    filter: grayscale(3) brightness(0.75) contrast(0.9);
  }
.card{
  transition: filter 0.5s ease;
}


@media (max-width: 768px){
  .title{
    flex-direction: column;     /* stack instead of row */
    align-items: center;
    gap: 12px;
  }

  .title-img{
    max-width: 90%;             /* prevent horizontal overflow */
    max-height: 140px;          /* smaller on mobile */
  }

  .logo-img{
    margin-left: 0;             /* disable right-push */
    max-height: 56px;
  }
}
.title{
  max-width: 100%;
  overflow: hidden;
}
/* Buy-me-a-coffee button under the card */
.bmc-wrap{
  margin-top: 14px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 18px;   /* space between coffee & info icons */
}


.bmc-btn{
  border: none;
  background: transparent;
  padding: 0;
  cursor: pointer;
}

.bmc-btn img{
  max-height: 90px;    /* tweak */
  width: auto;
  display: block;
}

/* Simple modal */
.modal-backdrop{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.55);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 5000;
  padding: 16px;
}

.modal-backdrop.show{ display: flex; }

.modal{
  width: min(520px, 92vw);
  background: #ffffff;
  border-radius: 18px;
  padding: 18px 18px 14px;
  box-shadow: 0 20px 60px rgba(0,0,0,.25);
}

.modal h2{
  margin: 0 0 8px;
  font-size: 1.2rem;
}

.modal p{
  margin: 0 0 14px;
  line-height: 1.35;
}

.modal-actions{
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  flex-wrap: wrap;
}

.modal a{
  text-decoration: none;
}

.btn{
  border: 1px solid rgba(0,0,0,.15);
  background: #fff;
  padding: 10px 12px;
  border-radius: 12px;
  cursor: pointer;
  font: inherit;
}

.btn.primary{
  border-color: transparent;
  background: rgba(17,138,178,.18);
}

.guess-row{
  display: flex;
  align-items: center;
  gap: 2px;
}

.guess-row .input-wrap{
  flex: 1;
  min-width: 0; /* prevents overflow weirdness */
}

.guess-row .msg{
  min-height: 0;        /* override old layout expectation */
  margin-top: 0;        /* remove the old top margin */
  white-space: nowrap;  /* keep ‚Äú‚úÖ Correct!‚Äù on one line */
  flex: 0 0 auto;
}

/* On very small screens, stack again if needed */
@media (max-width: 520px){
  .guess-row{
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
  .guess-row .msg{
    white-space: normal;
  }
}




</style>

</head>

<body>
<div class="bg" aria-hidden="true"></div>

<div class="wrap">
  <main class="card">
    <div class="topbar">
      <div>
        <h1 class="title">
          <img src="sprites/title2.jpeg" alt="Daily Pok√©Scribble" class="title-img" />
          <img src="sprites/logo.jpeg" alt="Logo" class="logo-img" />
        </h1>
        <p class="sub">Three scribbles a day! All scribbled by the awesome <strong>Chenipan</strong>.</p>
        <p class="sub" id="scribbleCount">--/1025 Pok√©mon Scribbled!</p>
      </div>

      <div class="toggle" title="Toggle background theme">
        <span>Light</span>
        <label class="switch" aria-label="Toggle dark background">
          <input id="bgToggle" type="checkbox" />
          <span class="slider"></span>
        </label>
        <span>Dark</span>
      </div>
    </div>

    <div class="hr" aria-hidden="true"></div>

    <div class="meta">
      <div class="pill">Next puzzles in: <span id="countdown">--:--:--</span></div>
      <div class="pill" id="todayTag"></div>
    </div>

    <section id="puzzles" class="grid" style="margin-top:16px;"></section>
  </main>
    <div class="bmc-wrap">
      <button class="bmc-btn" id="bmcOpen" aria-label="Buy me a coffee">
        <img src="sprites/buyme.jpeg" alt="Buy me a coffee" />
      </button>

      <button class="bmc-btn" id="infoOpen" aria-label="Project disclaimer">
        <img src="sprites/info.jpeg" alt="Project disclaimer" />
      </button>
    </div>



</div>

<!-- Sound (plays on every correct answer) -->
<audio id="rightSound" src="sfx/victory.mp3" preload="auto"></audio>

<!-- Buy Me a Coffee Modal -->
<div class="modal-backdrop" id="bmcModal" role="dialog" aria-modal="true" aria-labelledby="bmcTitle">
  <div class="modal">
    <h2 id="bmcTitle">Buy me a coffee?</h2>
    <p>If you‚Äôre enjoying Daily Pok√©Scribble, would you like to support Chenipan with a coffee?</p>

    <div class="modal-actions">
      <button class="btn" id="bmcClose">Not now</button>
      <a class="btn primary" href="https://buymeacoffee.com/chenipan" target="_blank" rel="noopener noreferrer">
        Yes ‚Äî take me there
      </a>
    </div>
  </div>
</div>

<!-- Disclaimer Modal -->
<div class="modal-backdrop" id="infoModal" role="dialog" aria-modal="true" aria-labelledby="infoTitle">
  <div class="modal">
    <h2 id="infoTitle">Fan Project Disclaimer</h2>

    <p>
      Pok√©mon and Pok√©mon character names are trademarks of Nintendo, Game Freak,
      and The Pok√©mon Company.
    </p>
    <p>
      This project is fan-made and is not endorsed, sponsored, or affiliated with Nintendo
      or any of its partners.
    </p>

    <p><strong>How to Play</strong><br>
      Every day, three scribbles will be revealed, and you have to guess today's Pok√©mon
      through those scribbles! Some are easier and some are harder to guess. Each scribble
      is done very quickly and without much thought, so good luck with guessing!
    </p>

    <p><strong>Credits</strong><br>
      Pokescribble is created by Omurice and Chenipan. All the drawings are done by
      Chenipan! Pokescribble is also inspired by pokedle.net and pokedle.com.
    </p>

    <p><strong>Contact</strong><br>
      If you have any questions, bug reports, feedback, or just wanna say hi, contact us here:<br>
      <strong>Discord: artisanalbreads</strong>
    </p>

    <div class="modal-actions">
      <button class="btn primary" id="infoClose">Got it</button>
    </div>
  </div>
</div>




<!-- Confetti library -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

<script>
/* ====== Config ====== */
const SPRITE_EXT = "jpeg"; // change to "png" if your images are .png
const PUZZLES_PER_DAY = 3;
const BG_KEY = "pokescribble_bg";

/* ====== Utilities ====== */
const msDay = 24*60*60*1000;
const normalize = s => s.toLowerCase().normalize("NFKD")
  .replace(/[\u0300-\u036f]/g,"")
  .replace(/[^a-z0-9]+/g,"")
  .trim();

function parseNamesTxt(text){
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const rows = [];
  for (const line of lines){
    if (/^number\b/i.test(line) || /^name\b/i.test(line)) continue;
    const parts = line.split(/\s+/);
    const num = parts.shift();
    const name = parts.join(' ');
    if (num && name) rows.push({ num, name });
  }
  return rows;
}

function maxDexNumber(dexRows){
  let max = 0;
  for (const r of dexRows){
    const n = parseInt(String(r.num).replace(/\D/g,''), 10);
    if (Number.isFinite(n) && n > max) max = n;
  }
  return max;
}

function pad3(n){ return String(n).padStart(3,'0'); }
function spritePathFor(num){ return `sprites/${pad3(num)}.${SPRITE_EXT}`; }

function spriteExists(path) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = path + "?cache=" + Math.random();
  });
}

/* ====== Background toggle ====== */
function applyBackground(mode){
  document.documentElement.style.setProperty(
    "--bg-image",
    mode === "dark" ? "var(--bg-dark)" : "var(--bg-light)"
  );

  document.body.classList.toggle("dark", mode === "dark");

  localStorage.setItem(BG_KEY, mode);
}

function initBackgroundToggle(){
  const toggle = document.getElementById("bgToggle");
  const saved = localStorage.getItem(BG_KEY) || "light";
  toggle.checked = (saved === "dark");
  applyBackground(saved);
  toggle.addEventListener("change", () => {
    applyBackground(toggle.checked ? "dark" : "light");
  });
}

/* ====== Deterministic random daily picks ====== */
function getDayKeyUTC(){
  const now = new Date();
  return Math.floor(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()) / msDay);
}

function mulberry32(seed){
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
async function pickDailyPokemons(dex, count){
  const dayKey = getDayKeyUTC();
  const rng = mulberry32(dayKey ^ (dex.length * 2654435761));

  const picked = [];
  const usedIdx = new Set();
  let safety = 0;

  while (picked.length < count && safety < dex.length * 6){
    safety++;
    const idx = Math.floor(rng() * dex.length);
    if (usedIdx.has(idx)) continue;

    const mon = dex[idx];
    const path = spritePathFor(mon.num);
    const ok = await spriteExists(path);

    usedIdx.add(idx);
    if (ok) picked.push(mon);
  }
  return picked;
}

/* ====== Countdown ====== */
function nextUTCMidnightCountdown(){
  const now = new Date();
  const next = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));
  const diff = next - now;

  const h = Math.max(0, Math.floor(diff/3600000));
  const m = Math.max(0, Math.floor((diff%3600000)/60000));
  const s = Math.max(0, Math.floor((diff%60000)/1000));
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

/* ====== Autocomplete ====== */
function attachAutocomplete(input, list, options, onPick){
  let items = []; let activeIndex = -1;

  function close(){ list.classList.add('hide'); list.innerHTML=''; activeIndex=-1; }
  function open(){ list.classList.remove('hide'); }

  function render(){
    list.innerHTML = '';
    items.forEach((opt, idx)=>{
      const div = document.createElement('div');
      div.className = 'ac-item';
      div.setAttribute('role','option');
      div.setAttribute('aria-selected', idx===activeIndex ? 'true':'false');
      div.innerHTML = `<span class="dex">#${opt.num}</span><span>${opt.name}</span>`;
      div.addEventListener('mousedown', e=>{ e.preventDefault(); pick(idx); });
      list.appendChild(div);
    });
    items.length ? open() : close();
  }

  function filter(){
    const q = normalize(input.value);
    if (!q){ close(); return; }
    const starts = [], contains = [];
    for (const o of options){
      const n = normalize(o.name);
      if (n.startsWith(q)) starts.push(o);
      else if (n.includes(q)) contains.push(o);
    }
    items = [...starts, ...contains].slice(0, 8);
    activeIndex = items.length ? 0 : -1;
    render();
  }

  function pick(idx){
    const opt = items[idx]; if (!opt) return;
    input.value = opt.name; close(); onPick(opt.name);
  }

  input.addEventListener('input', filter);
  input.addEventListener('focus', filter);
  input.addEventListener('blur', ()=> setTimeout(close, 100));
  input.addEventListener('keydown', e=>{
    if (list.classList.contains('hide')) return;
    if (e.key==='ArrowDown'){ e.preventDefault(); if (activeIndex<items.length-1) activeIndex++; render(); }
    else if (e.key==='ArrowUp'){ e.preventDefault(); if (activeIndex>0) activeIndex--; render(); }
    else if (e.key==='Enter'){ e.preventDefault(); if (activeIndex>=0) pick(activeIndex); }
    else if (e.key==='Escape'){ close(); }
  });
}

let bmcShown = false; // prevents repeat popups
function openBmcModal(){
  const modal = document.getElementById("bmcModal");
  if (!modal) return;
  modal.classList.add("show");
}


/* ====== Confetti + audio helpers ====== */
function originFromInput(inputEl){
  const r = inputEl.getBoundingClientRect();
  const x = (r.left + r.width / 2) / window.innerWidth;
  const y = (r.top + r.height / 2) / window.innerHeight;
  return { x, y };
}

function fireConfetti(level, origin){
  if (typeof confetti !== "function") return;

  if (level === 1){
    confetti({ particleCount: 90, spread: 60, startVelocity: 35, scalar: 1.0, origin });
  } else if (level === 2){
    confetti({ particleCount: 170, spread: 80, startVelocity: 45, scalar: 1.05, origin });
    setTimeout(() => confetti({ particleCount: 90, spread: 90, startVelocity: 35, scalar: 0.95, origin }), 180);
  } else {
    confetti({ particleCount: 280, spread: 100, startVelocity: 55, scalar: 1.15, origin });
    setTimeout(() => confetti({ particleCount: 160, spread: 120, startVelocity: 45, scalar: 1.05, origin }), 160);
    setTimeout(() => confetti({ particleCount: 140, spread: 130, startVelocity: 40, scalar: 1.0, origin }), 320);
  }
}

// Play sound on every correct answer. Use a tiny "cooldown" to avoid double-fire.
let lastSoundAt = 0;
function playRightSound(){
  const now = Date.now();
  if (now - lastSoundAt < 120) return; // prevents accidental double calls
  lastSoundAt = now;

  const audio = document.getElementById("rightSound");
  if (!audio) return;

  // If the user gets answers quickly, restart the sound.
  try{
    audio.pause();
    audio.currentTime = 0;
  } catch(e){}

  // In modern browsers this should work because it's triggered by Enter/click (a user gesture)
  audio.play().catch(()=>{});
}

/* ====== Render one puzzle card ====== */
const solvedSet = new Set(); // puzzle indexes that are currently correct

function renderPuzzleCard(mon, index, dex){
  const el = document.createElement('div');
  el.className = 'puzzle';

  el.innerHTML = `
    <div class="imgbox frame-${index + 1}">
      <img alt="Scribble ${index+1}" />
    </div>

    <div class="label">Your Guess</div>

    <div class="guess-row">
      <div class="input-wrap">
        <input placeholder="Start typing a Pok√©mon‚Ä¶" autocomplete="off" />
        <div class="ac-list hide" role="listbox" aria-label="Pok√©mon suggestions"></div>
      </div>
      <div class="msg" aria-live="polite"></div>
    </div>

  `;

  const img = el.querySelector('img');
  const input = el.querySelector('input');
  const list = el.querySelector('.ac-list');
  const msg = el.querySelector('.msg');

  img.src = spritePathFor(mon.num);
  img.alt = mon.name;

  function updateSolvedState(isCorrect){
    if (isCorrect) solvedSet.add(index);
    else solvedSet.delete(index);
  }

  function check(){
    const value = normalize(input.value);
    if (!value){
      msg.textContent='';
      msg.className='msg';
      updateSolvedState(false);
      return;
    }

    const correct = normalize(mon.name) === value;

    if (correct){
      msg.textContent = '‚úÖ Correct!';
      msg.className = 'msg ok';

    updateSolvedState(true);
    const solvedCount = solvedSet.size;

    // confetti from textbox
    const origin = originFromInput(input);
    fireConfetti(Math.min(3, Math.max(1, solvedCount)), origin);

    // sound on every correct
    playRightSound();

    // üéâ After the 3rd correct answer, show Buy Me a Coffee once
    if (solvedCount === 3 && !bmcShown){
      //bmcShown = true;

      // small delay so confetti finishes first
      //setTimeout(openBmcModal, 600);
    }

    } else {
      msg.textContent = '‚ùå Try again';
      msg.className = 'msg err';
      updateSolvedState(false);
    }
  }

  // Autocomplete pick triggers check
  attachAutocomplete(input, list, dex, () => check());

  // Only check on Enter (prevents blur/focus from firing anything)
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      check();
    }
  });

  return el;
}

/* ====== Boot ====== */
async function main(){
  initBackgroundToggle();

  const countdownEl = document.getElementById('countdown');
  const puzzlesEl = document.getElementById('puzzles');
  const todayTag = document.getElementById('todayTag');

  // Countdown
  countdownEl.textContent = nextUTCMidnightCountdown();
  setInterval(() => {
    countdownEl.textContent = nextUTCMidnightCountdown();
  }, 1000);

  // Date tag
  const todayStr = new Date().toLocaleDateString(undefined, { year:'numeric', month:'short', day:'2-digit' });
  todayTag.textContent = `Today: ${todayStr}`;

  // Load dex
  let dex = [];
  try{
    const res = await fetch('names.txt', { cache: "no-store" });
    dex = parseNamesTxt(await res.text());
    const scribbleEl = document.getElementById("scribbleCount");
    if (scribbleEl){
      const count = maxDexNumber(dex);
      scribbleEl.textContent = `${count}/1025 Pok√©mon Scribbled!`;
    }

  } catch(e){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Could not load Pok√©dex (names.txt). Make sure it‚Äôs in the repo root.</div></div>`;
    return;
  }

  if (!dex.length){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Pok√©dex loaded but empty. Check names.txt format.</div></div>`;
    return;
  }

  const picks = await pickDailyPokemons(dex, PUZZLES_PER_DAY);

  if (picks.length < PUZZLES_PER_DAY){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Not enough valid sprites found. Ensure sprites/NNN.${SPRITE_EXT} exists for many entries in names.txt.</div></div>`;
    return;
  }

  puzzlesEl.innerHTML = '';
  picks.forEach((mon, i) => puzzlesEl.appendChild(renderPuzzleCard(mon, i, dex)));
}

/* ===== Disclaimer modal ===== */
(function initInfoModal(){
  const openBtn = document.getElementById("infoOpen");
  const modal = document.getElementById("infoModal");
  const closeBtn = document.getElementById("infoClose");

  if (!openBtn || !modal || !closeBtn) return;

  function open(){
    modal.classList.add("show");
  }
  function close(){
    modal.classList.remove("show");
  }

  openBtn.addEventListener("click", open);
  closeBtn.addEventListener("click", close);

  // click outside closes
  modal.addEventListener("click", (e) => {
    if (e.target === modal) close();
  });

  // Esc closes
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") close();
  });
})();

/* ===== Buy Me a Coffee modal ===== */
(function initBmcModal(){
  const openBtn = document.getElementById("bmcOpen");
  const modal = document.getElementById("bmcModal");
  const closeBtn = document.getElementById("bmcClose");

  if (!openBtn || !modal || !closeBtn) return;

  function open(){
    modal.classList.add("show");
  }
  function close(){
    modal.classList.remove("show");
  }

  openBtn.addEventListener("click", open);
  closeBtn.addEventListener("click", close);

  // click outside modal closes
  modal.addEventListener("click", (e) => {
    if (e.target === modal) close();
  });

  // Esc closes
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") close();
  });
})();


main();
</script>

</body>
</html>
