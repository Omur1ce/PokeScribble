<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily PokéScribble — Guess the Pokémon</title>
<meta name="description" content="A daily Pokémon image guessing game with autocomplete.">

<style>
  :root{
    --glass: rgba(255,255,255,.78);
    --text:#1a1a1a;
    --accent:#ef476f;
    --accent2:#118ab2;
    --ok:#0a8f4a;
    --err:#d90429;

    --bg-light: url("sprites/background_light.jpg");
    --bg-dark:  url("sprites/background_dark.jpg");
    --bg-image: var(--bg-light);
  }

  html, body { height: 100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--text);
    background:#0b1020;
  }

  .bg{
    position:fixed; inset:0;
    background-image: var(--bg-image);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    z-index:-2;
  }
  .bg::after{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(900px 500px at 105% 20%, rgba(255,255,255,.45), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.28), rgba(0,0,0,.18));
    z-index:-1;
  }

  .wrap{ min-height:100%; display:grid; place-items:center; padding:5vh 16px; }
  .card{
    width:min(1100px, 96vw);
    background:var(--glass);
    border:1px solid rgba(0,0,0,.08);
    border-radius:20px;
    box-shadow:0 20px 60px rgba(0,0,0,.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: clamp(18px, 4vw, 36px);
  }

  .topbar{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }

  .title{ display:flex; gap:12px; align-items:center; margin:0 0 8px; text-transform:uppercase; letter-spacing:.02em; }
  .title b{ font-size: clamp(1.3rem, 3.6vw, 2.1rem); }
  .pokeball{ width:36px; height:36px; border-radius:50%; flex:0 0 auto;
    background:
      radial-gradient(circle at 50% 50%, #fff 0 7px, transparent 7px),
      linear-gradient(#ff3b3b 0 50%, #fff 50% 100%);
    border:3px solid #1a1a1a; box-shadow: inset 0 2px 0 rgba(0,0,0,.15), 0 6px 18px rgba(0,0,0,.15);
  }
  .sub{ margin:0 0 14px; color:#333; }
  .hr{ height:3px; border-radius:3px; background:linear-gradient(90deg, var(--accent), var(--accent2)); margin:10px 0 20px; }

  .meta{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; color:#333; }
  .pill{ background:#0000000e; padding:6px 10px; border-radius:999px; }

  .toggle{
    display:flex; align-items:center; gap:10px;
    background:#ffffffb0;
    border:1px solid rgba(0,0,0,.10);
    padding:8px 10px;
    border-radius:999px;
    user-select:none;
  }
  .toggle span{ font-size:.92rem; color:#222; }
  .switch{ position:relative; width:46px; height:26px; flex:0 0 auto; }
  .switch input{ opacity:0; width:0; height:0; }
  .slider{
    position:absolute; inset:0;
    background:rgba(0,0,0,.18);
    border-radius:999px;
    transition: .2s;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.08);
  }
  .slider:before{
    content:"";
    position:absolute; height:20px; width:20px; left:3px; top:3px;
    background:white;
    border-radius:50%;
    transition:.2s;
    box-shadow:0 6px 18px rgba(0,0,0,.18);
  }
  .switch input:checked + .slider{ background:rgba(17,138,178,.45); }
  .switch input:checked + .slider:before{ transform: translateX(20px); }

  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap: 16px;
  }
  @media (min-width: 900px){
    .grid{ grid-template-columns: repeat(3, 1fr); }
  }

  .puzzle{
    background:#fff;
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    padding: 14px;
    box-shadow:0 8px 24px rgba(0,0,0,.06);
    position:relative;
  }
  .imgbox{
    background:#fff;
    border:1px solid rgba(0,0,0,.08);
    border-radius:14px;
    padding:12px;
    display:grid;
    place-items:center;
    min-height:240px;
    position:relative;
    margin-bottom: 12px;
  }
  .imgbox img{
    max-width:100%;
    max-height:320px;
    object-fit:contain;
    filter: drop-shadow(0 6px 24px rgba(0,0,0,.12));
  }
  .tag{
    position:absolute; top:10px; left:10px;
    font-size:.85rem; background:#0000000f; padding:6px 10px; border-radius:999px;
  }
  .label{ font-weight:700; margin-bottom:8px; }
  .input-wrap{ position:relative; }
  input[type="text"]{
    width:100%;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.14);
    background:#fff;
    color:#111;
    font-size:1rem;
    outline:none;
  }
  input[type="text"]:focus{ border-color:var(--accent2); box-shadow:0 0 0 3px rgba(17,138,178,.20); }
  .msg{ min-height:1.25em; margin-top:10px; font-weight:700; }
  .ok{ color:var(--ok); } .err{ color:var(--err); }

  .ac-list{
    position:absolute; left:0; right:0; top:100%; z-index:20;
    margin-top:6px; max-height:220px; overflow:auto;
    background:#ffffff; border:1px solid rgba(0,0,0,.12); border-radius:12px;
    box-shadow:0 16px 40px rgba(0,0,0,.15);
  }
  .ac-item{ padding:10px 12px; cursor:pointer; display:flex; gap:8px; align-items:center; color:#111; }
  .ac-item:hover, .ac-item[aria-selected="true"]{ background:#f3f8ff; }
  .dex{ opacity:.7; font-variant-numeric:tabular-nums; min-width:3ch; }
  .hide{ display:none; }
</style>
</head>

<body>
<div class="bg" aria-hidden="true"></div>

<div class="wrap">
  <main class="card">
    <div class="topbar">
      <div>
        <h1 class="title">
          <span class="pokeball" aria-hidden="true"></span>
          <b>Daily PokéScribble</b>
          <span style="font-weight:400">— Guess the Pokémon</span>
        </h1>
        <p class="sub">Three scribbles a day! All scribbled by the awesome <strong>Chenipan</strong>.</p>
      </div>

      <div class="toggle" title="Toggle background theme">
        <span>Light</span>
        <label class="switch" aria-label="Toggle dark background">
          <input id="bgToggle" type="checkbox" />
          <span class="slider"></span>
        </label>
        <span>Dark</span>
      </div>
    </div>

    <div class="hr" aria-hidden="true"></div>

    <div class="meta">
      <div class="pill">Next puzzles in: <span id="countdown">--:--:--</span></div>
      <div class="pill" id="todayTag"></div>
    </div>

    <section id="puzzles" class="grid" style="margin-top:16px;"></section>
  </main>
</div>

<!-- Sound (plays on every correct answer) -->
<audio id="rightSound" src="sfx/victory.mp3" preload="auto"></audio>

<!-- Confetti library -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

<script>
/* ====== Config ====== */
const SPRITE_EXT = "jpeg"; // change to "png" if your images are .png
const PUZZLES_PER_DAY = 3;
const BG_KEY = "pokescribble_bg";

/* ====== Utilities ====== */
const msDay = 24*60*60*1000;
const normalize = s => s.toLowerCase().normalize("NFKD")
  .replace(/[\u0300-\u036f]/g,"")
  .replace(/[^a-z0-9]+/g,"")
  .trim();

function parseNamesTxt(text){
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const rows = [];
  for (const line of lines){
    if (/^number\b/i.test(line) || /^name\b/i.test(line)) continue;
    const parts = line.split(/\s+/);
    const num = parts.shift();
    const name = parts.join(' ');
    if (num && name) rows.push({ num, name });
  }
  return rows;
}
function pad3(n){ return String(n).padStart(3,'0'); }
function spritePathFor(num){ return `sprites/${pad3(num)}.${SPRITE_EXT}`; }

function spriteExists(path) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = path + "?cache=" + Math.random();
  });
}

/* ====== Background toggle ====== */
function applyBackground(mode){
  document.documentElement.style.setProperty(
    "--bg-image",
    mode === "dark" ? "var(--bg-dark)" : "var(--bg-light)"
  );
  localStorage.setItem(BG_KEY, mode);
}
function initBackgroundToggle(){
  const toggle = document.getElementById("bgToggle");
  const saved = localStorage.getItem(BG_KEY) || "light";
  toggle.checked = (saved === "dark");
  applyBackground(saved);
  toggle.addEventListener("change", () => {
    applyBackground(toggle.checked ? "dark" : "light");
  });
}

/* ====== Deterministic random daily picks ====== */
function getDayKeyLocal(){
  const d = new Date();
  d.setHours(0,0,0,0);
  return Math.floor(d.getTime()/msDay);
}
function mulberry32(seed){
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
async function pickDailyPokemons(dex, count){
  const dayKey = getDayKeyLocal();
  const rng = mulberry32(dayKey ^ (dex.length * 2654435761));

  const picked = [];
  const usedIdx = new Set();
  let safety = 0;

  while (picked.length < count && safety < dex.length * 6){
    safety++;
    const idx = Math.floor(rng() * dex.length);
    if (usedIdx.has(idx)) continue;

    const mon = dex[idx];
    const path = spritePathFor(mon.num);
    const ok = await spriteExists(path);

    usedIdx.add(idx);
    if (ok) picked.push(mon);
  }
  return picked;
}

/* ====== Countdown ====== */
function nextMidnightCountdown(){
  const now = new Date();
  const midnight = new Date(now);
  midnight.setHours(24,0,0,0);
  const diff = midnight - now;

  const h = Math.max(0, Math.floor(diff/3600000));
  const m = Math.max(0, Math.floor((diff%3600000)/60000));
  const s = Math.max(0, Math.floor((diff%60000)/1000));
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

/* ====== Autocomplete ====== */
function attachAutocomplete(input, list, options, onPick){
  let items = []; let activeIndex = -1;

  function close(){ list.classList.add('hide'); list.innerHTML=''; activeIndex=-1; }
  function open(){ list.classList.remove('hide'); }

  function render(){
    list.innerHTML = '';
    items.forEach((opt, idx)=>{
      const div = document.createElement('div');
      div.className = 'ac-item';
      div.setAttribute('role','option');
      div.setAttribute('aria-selected', idx===activeIndex ? 'true':'false');
      div.innerHTML = `<span class="dex">#${opt.num}</span><span>${opt.name}</span>`;
      div.addEventListener('mousedown', e=>{ e.preventDefault(); pick(idx); });
      list.appendChild(div);
    });
    items.length ? open() : close();
  }

  function filter(){
    const q = normalize(input.value);
    if (!q){ close(); return; }
    const starts = [], contains = [];
    for (const o of options){
      const n = normalize(o.name);
      if (n.startsWith(q)) starts.push(o);
      else if (n.includes(q)) contains.push(o);
    }
    items = [...starts, ...contains].slice(0, 8);
    activeIndex = items.length ? 0 : -1;
    render();
  }

  function pick(idx){
    const opt = items[idx]; if (!opt) return;
    input.value = opt.name; close(); onPick(opt.name);
  }

  input.addEventListener('input', filter);
  input.addEventListener('focus', filter);
  input.addEventListener('blur', ()=> setTimeout(close, 100));
  input.addEventListener('keydown', e=>{
    if (list.classList.contains('hide')) return;
    if (e.key==='ArrowDown'){ e.preventDefault(); if (activeIndex<items.length-1) activeIndex++; render(); }
    else if (e.key==='ArrowUp'){ e.preventDefault(); if (activeIndex>0) activeIndex--; render(); }
    else if (e.key==='Enter'){ e.preventDefault(); if (activeIndex>=0) pick(activeIndex); }
    else if (e.key==='Escape'){ close(); }
  });
}

/* ====== Confetti + audio helpers ====== */
function originFromInput(inputEl){
  const r = inputEl.getBoundingClientRect();
  const x = (r.left + r.width / 2) / window.innerWidth;
  const y = (r.top + r.height / 2) / window.innerHeight;
  return { x, y };
}

function fireConfetti(level, origin){
  if (typeof confetti !== "function") return;

  if (level === 1){
    confetti({ particleCount: 90, spread: 60, startVelocity: 35, scalar: 1.0, origin });
  } else if (level === 2){
    confetti({ particleCount: 170, spread: 80, startVelocity: 45, scalar: 1.05, origin });
    setTimeout(() => confetti({ particleCount: 90, spread: 90, startVelocity: 35, scalar: 0.95, origin }), 180);
  } else {
    confetti({ particleCount: 280, spread: 100, startVelocity: 55, scalar: 1.15, origin });
    setTimeout(() => confetti({ particleCount: 160, spread: 120, startVelocity: 45, scalar: 1.05, origin }), 160);
    setTimeout(() => confetti({ particleCount: 140, spread: 130, startVelocity: 40, scalar: 1.0, origin }), 320);
  }
}

// Play sound on every correct answer. Use a tiny "cooldown" to avoid double-fire.
let lastSoundAt = 0;
function playRightSound(){
  const now = Date.now();
  if (now - lastSoundAt < 120) return; // prevents accidental double calls
  lastSoundAt = now;

  const audio = document.getElementById("rightSound");
  if (!audio) return;

  // If the user gets answers quickly, restart the sound.
  try{
    audio.pause();
    audio.currentTime = 0;
  } catch(e){}

  // In modern browsers this should work because it's triggered by Enter/click (a user gesture)
  audio.play().catch(()=>{});
}

/* ====== Render one puzzle card ====== */
const solvedSet = new Set(); // puzzle indexes that are currently correct

function renderPuzzleCard(mon, index, dex){
  const el = document.createElement('div');
  el.className = 'puzzle';

  el.innerHTML = `
    <div class="imgbox">
      <div class="tag">Scribble ${index+1}</div>
      <img alt="Scribble ${index+1}" />
    </div>

    <div class="label">Your Guess</div>
    <div class="input-wrap">
      <input placeholder="Start typing a Pokémon…" autocomplete="off" />
      <div class="ac-list hide" role="listbox" aria-label="Pokémon suggestions"></div>
    </div>
    <div class="msg" aria-live="polite"></div>
  `;

  const img = el.querySelector('img');
  const input = el.querySelector('input');
  const list = el.querySelector('.ac-list');
  const msg = el.querySelector('.msg');

  img.src = spritePathFor(mon.num);
  img.alt = mon.name;

  function updateSolvedState(isCorrect){
    if (isCorrect) solvedSet.add(index);
    else solvedSet.delete(index);
  }

  function check(){
    const value = normalize(input.value);
    if (!value){
      msg.textContent='';
      msg.className='msg';
      updateSolvedState(false);
      return;
    }

    const correct = normalize(mon.name) === value;

    if (correct){
      msg.textContent = '✅ Correct!';
      msg.className = 'msg ok';

      // update solved set first so intensity matches 1/2/3 solved
      updateSolvedState(true);
      const solvedCount = solvedSet.size;

      // confetti from textbox
      const origin = originFromInput(input);
      fireConfetti(Math.min(3, Math.max(1, solvedCount)), origin);

      // sound on every correct
      playRightSound();
    } else {
      msg.textContent = '❌ Try again';
      msg.className = 'msg err';
      updateSolvedState(false);
    }
  }

  // Autocomplete pick triggers check
  attachAutocomplete(input, list, dex, () => check());

  // Only check on Enter (prevents blur/focus from firing anything)
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      check();
    }
  });

  return el;
}

/* ====== Boot ====== */
async function main(){
  initBackgroundToggle();

  const countdownEl = document.getElementById('countdown');
  const puzzlesEl = document.getElementById('puzzles');
  const todayTag = document.getElementById('todayTag');

  // Countdown
  countdownEl.textContent = nextMidnightCountdown();
  setInterval(() => {
    countdownEl.textContent = nextMidnightCountdown();
  }, 1000);

  // Date tag
  const todayStr = new Date().toLocaleDateString(undefined, { year:'numeric', month:'short', day:'2-digit' });
  todayTag.textContent = `Today: ${todayStr}`;

  // Load dex
  let dex = [];
  try{
    const res = await fetch('names.txt', { cache: "no-store" });
    dex = parseNamesTxt(await res.text());
  } catch(e){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Could not load Pokédex (names.txt). Make sure it’s in the repo root.</div></div>`;
    return;
  }

  if (!dex.length){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Pokédex loaded but empty. Check names.txt format.</div></div>`;
    return;
  }

  const picks = await pickDailyPokemons(dex, PUZZLES_PER_DAY);

  if (picks.length < PUZZLES_PER_DAY){
    puzzlesEl.innerHTML = `<div class="puzzle"><div class="msg err">Not enough valid sprites found. Ensure sprites/NNN.${SPRITE_EXT} exists for many entries in names.txt.</div></div>`;
    return;
  }

  puzzlesEl.innerHTML = '';
  picks.forEach((mon, i) => puzzlesEl.appendChild(renderPuzzleCard(mon, i, dex)));
}

main();
</script>

</body>
</html>
